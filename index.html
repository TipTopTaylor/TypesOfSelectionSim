<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Natural Selection Simulation - Isopods</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
  <style>
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      max-width: 1200px;
      margin: 0 auto;
      padding: 20px;
      background-color: #f8f9fa;
      color: #333;
    }
/* Achievements Panel */
    .achievements-panel {
      position: fixed;
      top: 20%;
      right: 0;
      display: flex;
      z-index: 900;
    }
    
    .achievements-toggle {
      background: linear-gradient(135deg, #4a4a4a 0%, #2a2a2a 100%);
      color: #FFC107;
      width: 40px;
      height: 40px;
      border-radius: 8px 0 0 8px;
      display: flex;
      justify-content: center;
      align-items: center;
      cursor: pointer;
      box-shadow: -2px 2px 8px rgba(0, 0, 0, 0.2);
      transition: all 0.3s ease;
    }
    
    .achievements-toggle:hover {
      width: 45px;
      color: #FFD54F;
    }
    
    .toggle-icon {
      font-size: 22px;
    }
    
    .achievements-container {
      background: rgba(42, 42, 42, 0.95);
      color: white;
      border-radius: 8px 0 0 8px;
      width: 0;
      overflow: hidden;
      transition: width 0.3s ease;
      box-shadow: -2px 2px 10px rgba(0, 0, 0, 0.3);
    }
    
    .achievements-panel.open .achievements-container {
      width: 300px;
      padding: 15px;
    }
    
    .achievements-panel h3 {
      margin-top: 0;
      color: #FFC107;
      font-family: 'Montserrat', sans-serif;
      font-weight: 700;
      font-size: 18px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.2);
      padding-bottom: 8px;
    }
    
    .achievements-list {
      display: flex;
      flex-direction: column;
      gap: 15px;
    }
    
    .achievement-item {
      display: flex;
      align-items: center;
      padding: 10px;
      border-radius: 8px;
      background: rgba(255, 255, 255, 0.1);
      transition: all 0.2s ease;
    }
    
    .achievement-item:hover {
      background: rgba(255, 255, 255, 0.15);
      transform: translateY(-2px);
    }
    
    .achievement-item .achievement-icon {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.2);
      display: flex;
      justify-content: center;
      align-items: center;
      font-size: 20px;
      margin-right: 12px;
      flex-shrink: 0;
    }
    
    .achievement-item.unlocked .achievement-icon {
      background: linear-gradient(135deg, #FFC107 0%, #FF9800 100%);
      box-shadow: 0 2px 6px rgba(255, 193, 7, 0.4);
    }
    
    .achievement-item.locked {
      filter: grayscale(0.8);
      opacity: 0.7;
    }
    
    .achievement-item.locked:hover {
      filter: grayscale(0.5);
      opacity: 0.9;
    }
    
    .achievement-details {
      flex: 1;
    }
    
    .achievement-name {
      font-weight: 600;
      font-size: 16px;
      margin-bottom: 4px;
    }
    
    .achievement-description {
      font-size: 12px;
      opacity: 0.8;
    }
/* Achievement toast */
    #achievement-toast {
      position: fixed;
      bottom: 30px;
      right: 30px;
      background: rgba(42, 42, 42, 0.95);
      color: white;
      padding: 0;
      border-radius: 12px;
      display: none;
      z-index: 1000;
      box-shadow: 0 5px 20px rgba(0, 0, 0, 0.4);
      transform: translateY(30px);
      opacity: 0;
      transition: transform 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275), 
                  opacity 0.3s ease;
      overflow: hidden;
      max-width: 350px;
    }

    #achievement-toast.show {
      transform: translateY(0);
      opacity: 1;
    }
    
    #achievement-toast .achievement-content {
      display: flex;
      align-items: center;
      padding: 16px;
    }
    
    #achievement-toast .achievement-icon {
      background: linear-gradient(135deg, #FFC107 0%, #FF9800 100%);
      width: 50px;
      height: 50px;
      border-radius: 50%;
      display: flex;
      justify-content: center;
      align-items: center;
      font-size: 28px;
      margin-right: 16px;
      box-shadow: 0 2px 8px rgba(255, 193, 7, 0.5);
      flex-shrink: 0;
    }
    
    #achievement-toast .achievement-text-container {
      flex: 1;
    }
    
    #achievement-toast .achievement-title {
      font-family: 'Montserrat', sans-serif;
      font-weight: 700;
      font-size: 14px;
      text-transform: uppercase;
      color: #FFC107;
      margin-bottom: 5px;
      letter-spacing: 0.5px;
    }
    
    #achievement-toast .achievement-message {
      font-family: 'Montserrat', sans-serif;
      font-weight: 600;
      font-size: 16px;
      color: white;
    }
    
    /* Animation pulse effect for the icon */
    @keyframes pulse {
      0% { transform: scale(1); }
      50% { transform: scale(1.05); }
      100% { transform: scale(1); }
    }
    
    #achievement-toast.show .achievement-icon {
      animation: pulse 1s infinite;
    }    // ───── Render ─────
    function updateDisplay() {
      document.getElementById('genCounter').textContent = generation;
      
      if (chart) {
        chart.data.datasets[0].data = currentDist;
        chart.update();
      }
      
      // Update selection status
      updateSelection();
    }

    function getSelectionTypeText() {
      switch(currentSelectionMode) {
        case 'stabilizing': return 'Stabilizing (Medium sizes favored)';
        case 'directional': return 'Directional (Large sizes favored)';
        case 'disruptive': return 'Disruptive (Small & Large sizes favored)';
        default: return 'None (Random drift only)';
      }
    }

    // ───── Selection Mode Presets ─────
    function selectMode(mode) {
      // Reset selection
      selectedCats = [];
      
      // Reset button styles
      document.querySelectorAll('#smallBtn, #mediumBtn, #largeBtn').forEach(btn => {
        btn.classList.remove('active');
      });
      
      currentSelectionMode = mode;
      
      // Apply appropriate selection
      switch(mode) {
        case 'stabilizing':
          toggleCat('medium');
          break;
        case 'directional':
          toggleCat('large');
          break;
        case 'disruptive':
          toggleCat('small');
          toggleCat('large');
          break;
        case 'noselection':
          // No selection
          break;
      }
      
      updateDisplay();
    }

    // ───── Breed button logic ─────
    function onBreed() {
      if (selectedCats.length === 0) {
        // No selection → jitter around baseline
        if (baselineNeedsSet) {
          baselineDist = [...currentDist];
          baselineNeedsSet = false;
        }
        currentDist = baselineDist.map(v => addNoise(v, NOISE_SCALE));
      } else {
        // Selection → drift from CURRENT toward target
        const target = computeTarget();
        currentDist = currentDist.map((v, i) => {
          let vNew = v * (1 - ALPHA) + target[i] * ALPHA;
          return addNoise(vNew, NOISE_SCALE);
        });
      }
      normalize(currentDist);
      generation++;
      
      // Regenerate isopods based on new distribution
      generateIsopods();
      
      updateDisplay();
    }

    // ───── Auto-Breeding ─────
    function toggleAutoBreed() {
      if (autoBreedInterval) {
        clearInterval(autoBreedInterval);
        autoBreedInterval = null;
        document.getElementById('autoBreedBtn').textContent = 'Auto-Breed';
      } else {
        const speed = parseInt(document.getElementById('breedSpeed').value);
        autoBreedInterval = setInterval(onBreed, speed);
        document.getElementById('autoBreedBtn').textContent = 'Stop Breeding';
      }
    }

    // ───── Reset Simulation ─────
    function resetSimulation() {
      // Stop auto-breeding if active
      if (autoBreedInterval) {
        clearInterval(autoBreedInterval);
        autoBreedInterval = null;
        document.getElementById('autoBreedBtn').textContent = 'Auto-Breed';
      }
      
      // Reset distribution to initial state
      initDist();
      generation = 0;
      
      // Clear selection
      selectedCats = [];
      document.querySelectorAll('#smallBtn, #mediumBtn, #largeBtn').forEach(btn => {
        btn.classList.remove('active');
      });
      
      // Reset selection mode
      selectMode('noselection');
      
      // Set canvas dimensions
      const canvas = document.getElementById('isopodCanvas');
      canvas.width = canvas.offsetWidth;
      canvas.height = canvas.offsetHeight;
      
      // Regenerate isopods
      generateIsopods();
      
      // Update display
      updateDisplay();
    }

    // ───── Trait toggle logic ─────
    function toggleCat(cat) {
      const idx = selectedCats.indexOf(cat);
      const btn = document.getElementById(cat + 'Btn');
      
      if (idx === -1) {
        selectedCats.push(cat);
        btn.classList.add('active');
      } else {
        selectedCats.splice(idx, 1);
        btn.classList.remove('active');
        baselineNeedsSet = true;
      }
      
      updateDisplay();
    }

    // ───── Handle Canvas Mouse Events ─────
    function handleCanvasMouseMove(e) {
      const canvas = document.getElementById('isopodCanvas');
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      
      let hoveredIsopod = null;
      
      // Check if mouse is over any isopod
      for (let i = isopods.length - 1; i >= 0; i--) {
        if (isopods[i].isPointInside(x, y)) {
          hoveredIsopod = isopods[i];
          break;
        }
      }
      
      if (hoveredIsopod) {
        // Show tooltip
        tooltip.style.display = 'block';
        tooltip.style.left = (e.clientX + 10) + 'px';
        tooltip.style.top = (e.clientY + 10) + 'px';
        tooltip.innerHTML = `Body Size: ${sizeToMillimeters(hoveredIsopod.size).toFixed(1)} mm<br>Status: ${hoveredIsopod.selected ? 'Selected' : 'Not Selected'}`;
        
        canvas.style.cursor = 'pointer';
      } else {
        // Hide tooltip
        tooltip.style.display = 'none';
        canvas.style.cursor = 'default';
      }
    }

    function handleCanvasMouseLeave() {
      tooltip.style.display = 'none';
      document.getElementById('isopodCanvas').style.cursor = 'default';
    }
    
    // ───── Handle Canvas Click to Toggle Isopod State ─────
    function handleCanvasClick(e) {
      const canvas = document.getElementById('isopodCanvas');
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      
      // Check if click is on any isopod
      for (let i = isopods.length - 1; i >= 0; i--) {
        if (isopods[i].isPointInside(x, y)) {
          // Toggle rolled up state
          isopods[i].rolledUp = !isopods[i].rolledUp;
          break; // Only toggle the topmost isopod
        }
      }
    }
    
    h1 {
      color: #2c3e50;
      margin-bottom: 5px;
      font-weight: 600;
    }
    
    h2 {
      color: #7f8c8d;
      font-size: 1.2em;
      margin-top: 0;
      font-weight: 400;
    }
    
    .container {
      width: 100%;
    }
    
    .instruction-box {
      background: linear-gradient(145deg, #ebf8ff 0%, #bee3f8 100%);
      border: 1px solid #90cdf4;
      border-radius: 12px;
      padding: 18px 22px;
      margin-bottom: 1.2rem;
      box-shadow: 0 2px 5px rgba(0,0,0,0.05);
    }
    
    .instruction-box p {
      margin: 0;
      color: #2a4365;
      font-size: 1.15rem;
      line-height: 1.5;
      font-weight: 500;
    }
    
    .selection-types {
      display: flex;
      justify-content: space-between;
      padding: 15px;
      background-color: white;
      border-radius: 8px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.05);
      border: 1px solid #eee;
      margin-bottom: 15px;
    }
    
    .selection-type {
      text-align: center;
      padding: 10px;
      border-radius: 6px;
      cursor: pointer;
      transition: background-color 0.2s;
      flex: 1;
      margin: 0 5px;
    }
    
    .selection-type:hover {
      background-color: #f0f0f0;
    }
    
    .selection-type.active {
      background-color: #4CAF50;
      color: white;
      box-shadow: 0 2px 5px rgba(76,175,80,0.3);
    }
    
    .info-box {
      background: linear-gradient(145deg, #ffffff 0%, #f8fafc 100%);
      border: 1px solid #e2e8f0;
      border-radius: 12px;
      padding: 18px;
      display: flex;
      justify-content: space-between;
      box-shadow: 0 4px 6px rgba(0,0,0,0.05), 0 1px 3px rgba(0,0,0,0.1);
      flex-wrap: wrap;
      margin-bottom: 1.2rem;
    }
    
    .info-display {
      flex: 1;
      min-width: 200px;
    }
    
    .info-display p {
      font-size: 1.1rem;
      margin: 5px 0;
    }
    
    .info-display strong {
      color: #2c5282;
      font-weight: 600;
    }
    
    #genCounter {
      font-weight: 700;
      color: #2b6cb0;
      font-size: 1.2rem;
    }
    
    .controls-container {
      display: flex;
      flex-wrap: wrap;
      gap: 15px;
      margin-top: 15px;
      margin-bottom: 1.5rem;
    }
    
    .trait-controls {
      display: flex;
      gap: 12px;
    }
    
    .simulation-controls {
      display: flex;
      gap: 12px;
      margin-left: auto;
    }
    
    .main-container {
      display: grid;
      grid-template-columns: 1fr 350px;
      gap: 20px;
      margin-top: 20px;
      height: calc(100vh - 280px);
      min-height: 500px;
    }
    
    .isopod-container {
      background-color: white;
      border-radius: 8px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.05);
      padding: 10px;
      border: 1px solid #eee;
      overflow: hidden;
      width: 100%;
      height: 100%;
    }
    
    .chart-container {
      background-color: white;
      border-radius: 8px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.05);
      padding: 15px;
      border: 1px solid #eee;
      height: 350px;
      align-self: flex-start;
    }
    
    canvas#isopodCanvas {
      width: 100%;
      height: 100%;
      display: block;
    }
    
    button {
      padding: 12px 20px;
      background: linear-gradient(145deg, #ffffff 0%, #f0f0f0 100%);
      border: 1px solid #e2e8f0;
      border-radius: 10px;
      cursor: pointer;
      font-size: 15px;
      font-weight: 600;
      transition: all 0.2s ease;
      box-shadow: 0 2px 5px rgba(0,0,0,0.1);
      color: #4a5568;
      font-family: 'Montserrat', sans-serif;
      letter-spacing: 0.3px;
      min-width: 120px;
      text-align: center;
    }
    
    button:hover {
      background: linear-gradient(145deg, #f8fafc 0%, #e2e8f0 100%);
      box-shadow: 0 4px 8px rgba(0,0,0,0.15);
      transform: translateY(-1px);
    }
    
    button.active {
      background: linear-gradient(145deg, #4CAF50 0%, #43A047 100%);
      color: white;
      opacity: 1 !important;
      box-shadow: 0 2px 5px rgba(76,175,80,0.4);
      border-color: #43A047;
    }
    
    button.active:hover {
      background: linear-gradient(145deg, #43A047 0%, #388E3C 100%);
      box-shadow: 0 4px 8px rgba(76,175,80,0.5);
    }
    
    select {
      padding: 10px 15px;
      border-radius: 10px;
      border: 1px solid #e2e8f0;
      background: linear-gradient(145deg, #ffffff 0%, #f8fafc 100%);
      font-size: 15px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.05);
      font-family: 'Montserrat', sans-serif;
      color: #4a5568;
      font-weight: 500;
      cursor: pointer;
    }
    
    select:hover {
      border-color: #cbd5e0;
      box-shadow: 0 2px 5px rgba(0,0,0,0.1);
    }
    
    #smallBtn {
      background: linear-gradient(145deg, #90cdf4 0%, #63b3ed 100%);
      color: #fff;
      border-color: #63b3ed;
    }
    
    #smallBtn:hover {
      background: linear-gradient(145deg, #63b3ed 0%, #4299e1 100%);
      border-color: #4299e1;
    }
    
    #smallBtn.active {
      background: linear-gradient(145deg, #3182ce 0%, #2b6cb0 100%);
      border-color: #2b6cb0;
      box-shadow: 0 2px 5px rgba(49, 130, 206, 0.4);
    }
    
    #mediumBtn {
      background: linear-gradient(145deg, #9ae6b4 0%, #68d391 100%);
      color: #fff;
      border-color: #68d391;
    }
    
    #mediumBtn:hover {
      background: linear-gradient(145deg, #68d391 0%, #48bb78 100%);
      border-color: #48bb78;
    }
    
    #mediumBtn.active {
      background: linear-gradient(145deg, #38a169 0%, #2f855a 100%);
      border-color: #2f855a;
      box-shadow: 0 2px 5px rgba(56, 161, 105, 0.4);
    }
    
    #largeBtn {
      background: linear-gradient(145deg, #fbd38d 0%, #f6ad55 100%);
      color: #fff;
      border-color: #f6ad55;
    }
    
    #largeBtn:hover {
      background: linear-gradient(145deg, #f6ad55 0%, #ed8936 100%);
      border-color: #ed8936;
    }
    
    #largeBtn.active {
      background: linear-gradient(145deg, #dd6b20 0%, #c05621 100%);
      border-color: #c05621;
      box-shadow: 0 2px 5px rgba(221, 107, 32, 0.4);
    }
    
    #breedBtn {
      background: linear-gradient(145deg, #48bb78 0%, #38a169 100%);
      color: white;
      border: none;
      border-color: #38a169;
    }
    
    #breedBtn:hover {
      background: linear-gradient(145deg, #38a169 0%, #2f855a 100%);
      border-color: #2f855a;
      box-shadow: 0 4px 8px rgba(56, 161, 105, 0.4);
    }
    
    #autoBreedBtn {
      background: linear-gradient(145deg, #4299e1 0%, #3182ce 100%);
      color: white;
      border: none;
      border-color: #3182ce;
    }
    
    #autoBreedBtn:hover {
      background: linear-gradient(145deg, #3182ce 0%, #2b6cb0 100%);
      border-color: #2b6cb0;
      box-shadow: 0 4px 8px rgba(49, 130, 206, 0.4);
    }
    
    #resetBtn {
      background: linear-gradient(145deg, #fc8181 0%, #f56565 100%);
      color: white;
      border: none;
      border-color: #f56565;
    }
    
    #resetBtn:hover {
      background: linear-gradient(145deg, #f56565 0%, #e53e3e 100%);
      border-color: #e53e3e;
      box-shadow: 0 4px 8px rgba(245, 101, 101, 0.4);
    }
    
    .tooltip {
      background-color: rgba(0,0,0,0.8);
      color: white;
      padding: 8px 12px;
      border-radius: 6px;
      position: absolute;
      display: none;
      pointer-events: none;
      font-size: 14px;
      box-shadow: 0 3px 8px rgba(0,0,0,0.2);
    }
    
    .speed-controls {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-left: auto;
    }
    
    @media (max-width: 900px) {
      .main-container {
        flex-direction: column;
      }
      
      .isopod-container, .chart-container {
        width: 100%;
      }
      
      .selection-types {
        flex-wrap: wrap;
      }
      
      .selection-type {
        min-width: 120px;
        margin-bottom: 10px;
      }
      
      .simulation-controls {
        margin-left: 0;
        margin-top: 10px;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="top-section">
      <h1>Natural Selection Simulation</h1>
      <h2>Exploring Selection Patterns with Isopod Body Size</h2>
      
      <div class="instruction-box">
        <p>Select which isopod sizes have the highest survival rate in this environment, then observe how the population changes over generations! You can select multiple sizes or change your selection at any time. Click on any isopod to toggle between rolled up and extended states.</p>
      </div>
      
      <div class="info-box">
        <div class="info-display">
          <p><strong>Generation:</strong> <span id="genCounter">0</span></p>
        </div>
        <div class="speed-controls">
          <label for="breedSpeed">Breeding Speed:</label>
          <select id="breedSpeed">
            <option value="2000">Slow</option>
            <option value="1000" selected>Medium</option>
            <option value="500">Fast</option>
          </select>
        </div>
      </div>
      
      <div class="controls-container">
	<h3 class="controls-heading">Select Highest Fitness:</h3>
        <div class="trait-controls">
          <button id="smallBtn">Small Isopods</button>
          <button id="mediumBtn">Medium Isopods</button>
          <button id="largeBtn">Large Isopods</button>
        </div>
        
        <div class="simulation-controls">
          <button id="breedBtn">Breed Next Generation</button>
          <button id="autoBreedBtn">Auto-Breed</button>
          <button id="resetBtn">Reset</button>
        </div>
      </div>
    </div>
    
    <div class="main-container">
      <div class="isopod-container">
        <canvas id="isopodCanvas"></canvas>
      </div>
      
      <div class="chart-container">
        <canvas id="distChart"></canvas>
      </div>
    </div>
  </div>
<!-- Achievement Panel -->
<div class="achievements-panel">
  <div class="achievements-toggle">
    <span class="toggle-icon">🏆</span>
  </div>
  <div class="achievements-container">
    <h3>Achievements</h3>
    <div class="achievements-list">
      <div class="achievement-item locked" id="rolling-achievement" title="Roll up all isopods at once">
        <div class="achievement-icon">🔒</div>
        <div class="achievement-details">
          <div class="achievement-name">They See Me Rolling</div>
          <div class="achievement-description">Get all isopods to roll up simultaneously</div>
        </div>
      </div>
    </div>
  </div>
</div>
  <!-- Achievement Toast -->
  <div id="achievement-toast">
  </div>

  

  <script>
    // ───── Parameters ─────
    const NUM_BINS     = 20;
    const TRAIT_MIN    = 0;
    const TRAIT_MAX    = 100;
    const GAUSS_MEAN   = 50;
    const GAUSS_SD     = 15;
    const NOISE_SCALE  = 0.02;  // 2% jitter (moderate)
    const ALPHA        = 0.08;  // 8% drift toward target per click (increased for faster evolution)
    const MEDIAN_SD    = GAUSS_SD / 2;
    const NUM_ISOPODS  = 100;   // Number of isopods to display
    
    // Disruptive selection parameters (in the 0-100 scale, will be displayed as mm)
    const DISRUPTIVE_SMALL_MEAN = 10;   // Small peak (will show as ~3mm)
    const DISRUPTIVE_LARGE_MEAN = 85;   // Large peak (will show as ~17mm)
    const DISRUPTIVE_SMALL_SD = 7;      // Narrow peak for small isopods
    const DISRUPTIVE_LARGE_SD = 7;      // Narrow peak for large isopods
    const DISRUPTIVE_VALLEY_DEPTH = 0.01; // Extremely reduced middle values
    
    // Isopod image aspect ratios (width / height)
    const ISOPOD_ASPECT_RATIO = 291 / 231; // Your provided dimensions
    const ROLLEDUP_ASPECT_RATIO = 1; // Assuming roughly square for rolled up
    
    // ───── State ─────
    let currentDist     = Array(NUM_BINS).fill(0);
    let baselineDist    = Array(NUM_BINS).fill(0);
    let baselineNeedsSet = false;
    let generation      = 0;
    let selectedCats    = [];
    let isopods         = [];
    let autoBreedInterval = null;
    let currentSelectionMode = 'noselection';
    let tooltip = null;
    let achievementGiven = false;

    const catParams = {
      small:  { mean: TRAIT_MIN + (TRAIT_MAX - TRAIT_MIN) / 4,     sd: GAUSS_SD },
      medium: { mean: GAUSS_MEAN,                                  sd: MEDIAN_SD },
      large:  { mean: TRAIT_MIN + 3 * (TRAIT_MAX - TRAIT_MIN) / 4, sd: GAUSS_SD }
    };
// ───── Achievement Panel Functions ─────
    function toggleAchievementPanel() {
      const panel = document.querySelector('.achievements-panel');
      panel.classList.toggle('open');
    }
    
    function updateAchievement(id, unlocked) {
      const achievement = document.getElementById(id);
      if (!achievement) return;
      
      if (unlocked) {
        achievement.classList.remove('locked');
        achievement.classList.add('unlocked');
        // Replace the lock icon with a trophy
        const icon = achievement.querySelector('.achievement-icon');
        icon.textContent = '🏆';
      }
    }

    // ───── Achievement Helpers ─────
    function showAchievement(msg) {
      if (achievementGiven) return;
      achievementGiven = true;
      
      const toast = document.getElementById('achievement-toast');
      toast.innerHTML = `
        <div class="achievement-content">
          <div class="achievement-icon">🏆</div>
          <div class="achievement-text-container">
            <div class="achievement-title">Achievement Unlocked!</div>
            <div class="achievement-message">${msg.replace('🏆 Achievement Unlocked: ', '')}</div>
          </div>
        </div>
      `;
      
      // Play achievement sound
      const sound = new Audio('achievement-sound.mp3');
      sound.volume = 0.7;
      sound.play().catch(e => console.log('Could not play achievement sound:', e));
      
      // Show with animation
      toast.style.display = 'block';
      setTimeout(() => toast.classList.add('show'), 10);
      
      // Hide toast after duration
      setTimeout(() => {
        toast.classList.remove('show');
        setTimeout(() => toast.style.display = 'none', 300);
      }, 4000);
      
      // Update achievement panel
      updateAchievement('rolling-achievement', true);
    }

    function checkAllRolledUp() {
      if (isopods.length && isopods.every(iso => iso.rolledUp)) {
        showAchievement('They see me rolling!');
      }
    }
    
    // ───── Canvas Click Handler (with achievement) ─────
    function handleCanvasClick(e) {
      const rect = e.target.getBoundingClientRect();
      const x = e.clientX - rect.left, y = e.clientY - rect.top;
      for (let i = isopods.length - 1; i >= 0; i--) {
        if (isopods[i].isPointInside(x, y)) {
          isopods[i].rolledUp = !isopods[i].rolledUp;
          checkAllRolledUp();
          break;
        }
      }
    }
    // ───── Helpers ─────
    function normalize(arr) {
      const sum = arr.reduce((s, x) => s + x, 0);
      if (sum === 0) return arr;
      for (let i = 0; i < arr.length; i++) {
        arr[i] = arr[i] / sum;
      }
      return arr;
    }
    
    function gaussian(x, mean, sd) {
      return Math.exp(-((x - mean)**2) / (2 * sd**2));
    }
    
    function addNoise(v, scale) {
      return v + (Math.random() * 2 - 1) * scale * v;
    }

    function getTraitBin(trait) {
      const binWidth = (TRAIT_MAX - TRAIT_MIN) / NUM_BINS;
      return Math.min(Math.floor((trait - TRAIT_MIN) / binWidth), NUM_BINS - 1);
    }
    
    // Convert simulation size (0-100) to millimeters (1-20mm) for display only
    function sizeToMillimeters(size) {
      return 1 + (size / 100) * 19; // Maps 0 to 1mm and 100 to 20mm
    }

    // ───── Initialize Distribution & Baseline ─────
    function initDist() {
      const width = (TRAIT_MAX - TRAIT_MIN) / NUM_BINS;
      for (let i = 0; i < NUM_BINS; i++) {
        const x = TRAIT_MIN + (i + 0.5) * width;
        currentDist[i] = gaussian(x, GAUSS_MEAN, GAUSS_SD);
      }
      normalize(currentDist);
      baselineDist = [...currentDist];
    }

    // ───── Compute target Gaussian mixture ─────
    function computeTarget() {
      const width = (TRAIT_MAX - TRAIT_MIN) / NUM_BINS;
      let target = Array(NUM_BINS).fill(0);
      
      if (selectedCats.includes('small') && selectedCats.includes('large') && !selectedCats.includes('medium')) {
        // Special case for disruptive selection - create extreme bimodal distribution
        for (let i = 0; i < NUM_BINS; i++) {
          const x = TRAIT_MIN + (i + 0.5) * width;
          
          // Create two peaks at the extremes
          const smallPeak = gaussian(x, DISRUPTIVE_SMALL_MEAN, DISRUPTIVE_SMALL_SD);
          const largePeak = gaussian(x, DISRUPTIVE_LARGE_MEAN, DISRUPTIVE_LARGE_SD);
          
          // Calculate how far we are from either peak (to determine valley)
          const distToSmall = Math.abs(x - DISRUPTIVE_SMALL_MEAN);
          const distToLarge = Math.abs(x - DISRUPTIVE_LARGE_MEAN);
          const minDist = Math.min(distToSmall, distToLarge);
          
          // If we're not close to either peak, apply severe suppression
          let value = smallPeak + largePeak;
          if (minDist > 15) {
            value *= DISRUPTIVE_VALLEY_DEPTH; // Extreme reduction in the middle
          }
          
          target[i] = value;
        }
      } else {
        // Standard behavior for other selection types
        selectedCats.forEach(cat => {
          const { mean, sd } = catParams[cat];
          for (let i = 0; i < NUM_BINS; i++) {
            const x = TRAIT_MIN + (i + 0.5) * width;
            target[i] += gaussian(x, mean, sd);
          }
        });
      }
      return normalize([...target]);
    }

    // ───── Isopod Class ─────
    class Isopod {
      constructor(x, y, size) {
        this.x = x;
        this.y = y;
        this.size = size;  // 0-100 trait value
        this.selected = false;
        this.angle = Math.random() * Math.PI * 2; // Random direction for movement only
        this.speed = 0.08 + Math.random() * 0.12;   // Slower movement speed
        this.rolledUp = Math.random() < 0.2; // 20% chance to be rolled up
        
        // Fixed aspect ratios for images
        this.extendedAspectRatio = ISOPOD_ASPECT_RATIO;
        this.rolledAspectRatio = ROLLEDUP_ASPECT_RATIO;
      }

      isPointInside(px, py) {
        const visualSize = this.getVisualSize();
        
        // Simple circular hit detection
        const distance = Math.sqrt((px - this.x) ** 2 + (py - this.y) ** 2);
        return distance <= visualSize / 1.5;
      }

      getVisualSize() {
        // Convert 0-100 trait to a visual size between 10-50 pixels
        return 15 + (this.size / 100) * 40;
      }

      update() {
        // Random movement - less frequent direction changes
        if (Math.random() < 0.01) {
          this.angle += (Math.random() - 0.5) * 0.4;
          // Random chance to change rolled state
          if (Math.random() < 0.003) {
            this.rolledUp = !this.rolledUp;
          }
        }
        
        // If rolled up, move slower
        const moveSpeed = this.rolledUp ? this.speed * 0.2 : this.speed;
        
        // Move in direction of angle (but display upright)
        this.x += Math.cos(this.angle) * moveSpeed;
        this.y += Math.sin(this.angle) * moveSpeed;
        
        const canvas = document.getElementById('isopodCanvas');
        const margin = this.getVisualSize() / 2;
        
        // Bounce off edges
        if (this.x < margin) {
          this.x = margin;
          this.angle = Math.PI - this.angle;
        } else if (this.x > canvas.width - margin) {
          this.x = canvas.width - margin;
          this.angle = Math.PI - this.angle;
        }
        
        if (this.y < margin) {
          this.y = margin;
          this.angle = -this.angle;
        } else if (this.y > canvas.height - margin) {
          this.y = canvas.height - margin;
          this.angle = -this.angle;
        }
      }

      draw(ctx) {
        const baseSize = this.getVisualSize();
        
        ctx.save();
        ctx.translate(this.x, this.y);
        // No rotation - isopods always upright
        
        // Calculate dimensions based on aspect ratio
        let imgWidth, imgHeight;
        
        if (this.rolledUp) {
          // Rolledup isopod
          imgHeight = baseSize;
          imgWidth = imgHeight * this.rolledAspectRatio;
        } else {
          // Extended isopod - maintain aspect ratio
          imgHeight = baseSize;
          imgWidth = imgHeight * this.extendedAspectRatio;
        }
        
        try {
          // Draw the isopod image with correct aspect ratio
          const img = this.rolledUp ? rolledImg : extendedImg;
          ctx.drawImage(
            img,
            -imgWidth / 2,
            -imgHeight / 2,
            imgWidth,
            imgHeight
          );
        } catch (e) {
          // Fallback to circles if image drawing fails
          ctx.fillStyle = this.selected ? '#76b852' : '#c77c7c';
          
          if (this.rolledUp) {
            // Circle for rolled up
            ctx.beginPath();
            ctx.arc(0, 0, baseSize/2, 0, Math.PI * 2);
            ctx.fill();
          } else {
            // Oval for extended
            ctx.beginPath();
            ctx.ellipse(0, 0, imgWidth/2, imgHeight/2, 0, 0, Math.PI * 2);
            ctx.fill();
          }
        }
        
        ctx.restore();
      }
    }

    // ───── Preload Images ─────
    const extendedImg = new Image();
    const rolledImg = new Image();
    extendedImg.src = "isopod.png";
    rolledImg.src = "rolledup.png";


    // ───── Chart.js setup ─────
    let chart = null;
    
    function setupChart() {
      const ctx = document.getElementById('distChart').getContext('2d');
      
      // Set chart size
      const chartCanvas = document.getElementById('distChart');
      chartCanvas.width = chartCanvas.parentElement.offsetWidth - 30; // Adjust for padding
      chartCanvas.height = 370;
      
      // Create labels based on original bins but display them as mm
      const labels = Array.from({ length: NUM_BINS }, (_, i) => {
        const binSize = (TRAIT_MAX - TRAIT_MIN) / NUM_BINS;
        const traitValue = TRAIT_MIN + i * binSize;
        // Convert to mm scale for display only
        return Math.round(sizeToMillimeters(traitValue));
      });
      
      chart = new Chart(ctx, {
        type: 'line',
        data: {
          labels: labels,
          datasets: [{
            label: 'Population Distribution',
            data: currentDist,
            fill: true,
            tension: 0.4,
            borderWidth: 3,
            borderColor: '#3e95cd',
            backgroundColor: 'rgba(62, 149, 205, 0.2)',
            pointRadius: 2
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            x: { 
              title: { display: true, text: 'Body Size (mm)', font: { weight: 'bold', size: 12 } },
              ticks: { 
                maxRotation: 0, 
                autoSkip: true, 
                maxTicksLimit: 10,
                font: { size: 10 }
              }
            },
            y: { 
              title: { display: true, text: 'Number of Individuals', font: { weight: 'bold', size: 12 } }, 
              beginAtZero: true,
              ticks: { 
                font: { size: 10 },
                callback: function(value) {
                  // Show as count instead of proportion
                  return Math.round(value * NUM_ISOPODS);
                }
              }
            }
          },
          plugins: {
            legend: {
              display: false
            },
            title: {
              display: true,
              text: 'Size Distribution',
              font: { size: 16, weight: 'bold' }
            }
          }
        }
      });
    }

    // ───── Generate Isopods from Distribution ─────
    function generateIsopods() {
      const canvas = document.getElementById('isopodCanvas');
      isopods = [];
      
      // Create a cumulative distribution for sampling
      let cumulativeDist = [];
      let sum = 0;
      for (let i = 0; i < currentDist.length; i++) {
        sum += currentDist[i];
        cumulativeDist.push(sum);
      }
      
      // Generate isopods according to distribution
      for (let i = 0; i < NUM_ISOPODS; i++) {
        // Use almost the full canvas, leaving some margin
        const margin = 50;
        const x = margin + Math.random() * (canvas.width - margin * 2);
        const y = margin + Math.random() * (canvas.height - margin * 2);
        
        // Sample from distribution
        const r = Math.random();
        let bin = 0;
        while (bin < cumulativeDist.length - 1 && r > cumulativeDist[bin]) {
          bin++;
        }
        
        // Calculate trait value (middle of bin plus small random offset)
        const binWidth = (TRAIT_MAX - TRAIT_MIN) / NUM_BINS;
        const traitBase = TRAIT_MIN + bin * binWidth;
        const trait = traitBase + Math.random() * binWidth;
        
        isopods.push(new Isopod(x, y, trait));
      }
    }

    // ───── Draw Isopods ─────
    function drawIsopods() {
      const canvas = document.getElementById('isopodCanvas');
      
      // Set canvas size to match container
      canvas.width = canvas.offsetWidth;
      canvas.height = canvas.offsetHeight;
      
      const ctx = canvas.getContext('2d');
      
      // Clear canvas
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      // Update and draw each isopod
      isopods.forEach(isopod => {
        isopod.update();
        isopod.draw(ctx);
      });
      
      // Request next frame
      requestAnimationFrame(drawIsopods);
    }

    // ───── Update Selection Status ─────
    function updateSelection() {
      if (selectedCats.length === 0) {
        // No selection - all isopods survive
        isopods.forEach(isopod => {
          isopod.selected = true;
        });
        return;
      }
      
      // Create target distribution for current selection
      const target = computeTarget();
      
      // Calculate selection probability for each bin
      const selectionProb = currentDist.map((current, i) => {
        if (current === 0) return 0;
        // Cap at 1.0 to avoid over-selection
        return Math.min(1.0, target[i] / current);
      });
      
      // Apply selection to isopods
      isopods.forEach(isopod => {
        const bin = getTraitBin(isopod.size);
        // Random selection based on bin probability
        isopod.selected = Math.random() < selectionProb[bin];
      });
    }

    // ───── Render ─────
    function updateDisplay() {
      document.getElementById('genCounter').textContent = generation;
      
      if (chart) {
        chart.data.datasets[0].data = currentDist;
        chart.update();
      }
      
      // Update selection status
      updateSelection();
    }

    function getSelectionTypeText() {
      switch(currentSelectionMode) {
        case 'stabilizing': return 'Stabilizing (Medium sizes favored)';
        case 'directional': return 'Directional (Large sizes favored)';
        case 'disruptive': return 'Disruptive (Small & Large sizes favored)';
        default: return 'None (Random drift only)';
      }
    }

    // ───── Selection Mode Presets ─────
    function selectMode(mode) {
      // Reset selection
      selectedCats = [];
      
      // Reset button styles
      document.querySelectorAll('#smallBtn, #mediumBtn, #largeBtn').forEach(btn => {
        btn.classList.remove('active');
      });
      
      currentSelectionMode = mode;
      
      // Apply appropriate selection
      switch(mode) {
        case 'stabilizing':
          toggleCat('medium');
          break;
        case 'directional':
          toggleCat('large');
          break;
        case 'disruptive':
          toggleCat('small');
          toggleCat('large');
          break;
        case 'noselection':
          // No selection
          break;
      }
      
      updateDisplay();
    }

    // ───── Breed button logic ─────
    function onBreed() {
      if (selectedCats.length === 0) {
        // No selection → jitter around baseline
        if (baselineNeedsSet) {
          baselineDist = [...currentDist];
          baselineNeedsSet = false;
        }
        currentDist = baselineDist.map(v => addNoise(v, NOISE_SCALE));
      } else {
        // Selection → drift from CURRENT toward target
        const target = computeTarget();
        currentDist = currentDist.map((v, i) => {
          let vNew = v * (1 - ALPHA) + target[i] * ALPHA;
          return addNoise(vNew, NOISE_SCALE);
        });
      }
      normalize(currentDist);
      generation++;
      
      // Regenerate isopods based on new distribution
      generateIsopods();
      
      updateDisplay();
    }

    // ───── Auto-Breeding ─────
    function toggleAutoBreed() {
      if (autoBreedInterval) {
        clearInterval(autoBreedInterval);
        autoBreedInterval = null;
        document.getElementById('autoBreedBtn').textContent = 'Auto-Breed';
      } else {
        const speed = parseInt(document.getElementById('breedSpeed').value);
        autoBreedInterval = setInterval(onBreed, speed);
        document.getElementById('autoBreedBtn').textContent = 'Stop Breeding';
      }
    }

    // ───── Reset Simulation ─────
    function resetSimulation() {
      // Stop auto-breeding if active
      if (autoBreedInterval) {
        clearInterval(autoBreedInterval);
        autoBreedInterval = null;
        document.getElementById('autoBreedBtn').textContent = 'Auto-Breed';
      }
      
      // Reset distribution to initial state
      initDist();
      generation = 0;
      
      // Clear selection
      selectedCats = [];
      document.querySelectorAll('#smallBtn, #mediumBtn, #largeBtn').forEach(btn => {
        btn.classList.remove('active');
      });
      
      // Reset selection mode
      currentSelectionMode = 'noselection';
      
      // Set canvas dimensions
      const canvas = document.getElementById('isopodCanvas');
      canvas.width = canvas.offsetWidth;
      canvas.height = canvas.offsetHeight;
      
      // Regenerate isopods
      generateIsopods();
      
      // Update display
      updateDisplay();
    }

    // ───── Trait toggle logic ─────
    function toggleCat(cat) {
      const idx = selectedCats.indexOf(cat);
      const btn = document.getElementById(cat + 'Btn');
      
      if (idx === -1) {
        selectedCats.push(cat);
        btn.classList.add('active');
      } else {
        selectedCats.splice(idx, 1);
        btn.classList.remove('active');
        baselineNeedsSet = true;
      }
      
      updateDisplay();
    }

    // ───── Handle Canvas Mouse Events ─────
    function handleCanvasMouseMove(e) {
      const canvas = document.getElementById('isopodCanvas');
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      
      let hoveredIsopod = null;
      
      // Check if mouse is over any isopod
      for (let i = isopods.length - 1; i >= 0; i--) {
        if (isopods[i].isPointInside(x, y)) {
          hoveredIsopod = isopods[i];
          break;
        }
      }
      
      if (hoveredIsopod) {
        // Show tooltip
        tooltip.style.display = 'block';
        tooltip.style.left = (e.clientX + 10) + 'px';
        tooltip.style.top = (e.clientY + 10) + 'px';
        tooltip.innerHTML = `Body Size: ${sizeToMillimeters(hoveredIsopod.size).toFixed(1)} mm<br>Status: ${hoveredIsopod.selected ? 'Selected' : 'Not Selected'}`;
        
        canvas.style.cursor = 'pointer';
      } else {
        // Hide tooltip
        tooltip.style.display = 'none';
        canvas.style.cursor = 'default';
      }
    }

    function handleCanvasMouseLeave() {
      tooltip.style.display = 'none';
      document.getElementById('isopodCanvas').style.cursor = 'default';
    }
    

    // Function to initialize simulation
    function initSimulation() {
      // Initialize tooltip
      tooltip = document.getElementById('tooltip');
      
      // Initialize simulation
      initDist();
      setupChart();
      
      // Set initial canvas dimensions
      const canvas = document.getElementById('isopodCanvas');
      canvas.width = canvas.offsetWidth;
      canvas.height = canvas.offsetHeight;
      
      // Generate isopods
      generateIsopods();
      
      // Update display
      updateDisplay();
      
      // Start animation loop
      drawIsopods();
    }

    // ───── Initialize & Start ─────
    document.addEventListener('DOMContentLoaded', function() {
      // Add Google Font
      const fontLink = document.createElement('link');
      fontLink.href = 'https://fonts.googleapis.com/css2?family=Montserrat:wght@400;500;600;700&display=swap';
      fontLink.rel = 'stylesheet';
      document.head.appendChild(fontLink);
      
      // Wire up UI
      document.getElementById('breedBtn').addEventListener('click', onBreed);
      document.getElementById('resetBtn').addEventListener('click', resetSimulation);
      document.getElementById('autoBreedBtn').addEventListener('click', toggleAutoBreed);
      document.querySelector('.achievements-toggle').addEventListener('click', toggleAchievementPanel);
      ['small','medium','large'].forEach(cat => {
        document.getElementById(cat + 'Btn')
          .addEventListener('click', () => toggleCat(cat));
      });
      
      const canvas = document.getElementById('isopodCanvas');
      canvas.addEventListener('mousemove', handleCanvasMouseMove);
      canvas.addEventListener('mouseleave', handleCanvasMouseLeave);
      canvas.addEventListener('click', handleCanvasClick);
      
      // Initialize the simulation
      initSimulation();
    });
    
    // Additional safety for ensuring everything is loaded
    window.onload = function() {
      // If isopods array is empty, reinitialize the simulation
      if (isopods.length === 0) {
        console.log("Reinitializing simulation to ensure isopods are generated");
        resetSimulation();
      }
	
      new Audio('achievement-sound.mp3').load();	
    };

	
  </script>
</body>
</html>
  
